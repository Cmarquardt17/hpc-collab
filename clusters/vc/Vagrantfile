# -*- mode: ruby -*-
# vim: set ft=ruby tabstop=2 shiftwidth=2 syntax=on background=dark :

require 'pathname'

REPODISK_SIZE = 16	# Gb

clustername_fullpath_raw = %x[pwd]
clustername_fullpath     = "#{clustername_fullpath_raw}"
clustername_fullpath     = #{clustername_fullpath}.chomp
clustername              = Pathname.new(clustername_fullpath).basename
clustername              = "#{clustername}".chomp

ENV["LC_ALL"] = "en_US.UTF-8"
ENV["VC"]     = "#{clustername}"

# the following will be replaced per-cluster with the constructed nodes table

nodes = {
 "vcfs" => {
    :ip  => "192.168.56.79",
    :mac => "5CA1AB1E00F5",
    :bridge => nil,
    :memory => "6656",
    :cpus => "4",
    :ingestfromhost => {	
      path: "../../bin/ingestfromhost.sh",
      args: "vcfs :DOTFILES :DOTSSH"
    },
    :adddiskpath => "/tmp/vcfs_repodisk.vdi"
 },
 "vcsvc" => {
    :ip  => "192.168.56.71",
    :mac => "5CA1AB1E051C",
    :bridge => nil,
    :memory => "768",
    :cpus => "2",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vcbuild" => {
    :ip  => "192.168.56.75",
    :mac => "5CA1AB1E00B1",
    :bridge => nil,
    :memory => "2560",
    :cpus => "2",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vcaltdb" => {
    :ip  => "192.168.56.76",
    :mac => "5CA1AB1EA1DB",
    :bridge => nil,
    :memory => "1024",
    :cpus => "2",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vcdb" => {
    :ip  => "192.168.56.77",
    :mac => "5CA1AB1E00DB",
    :bridge => nil,
    :memory => "2304",
    :cpus => "2",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vcsched" => {
    :ip  => "192.168.56.64",
    :mac => "5CA1AB1E0000",
    :bridge => nil,
    :memory => "1024",
    :cpus => "2",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vc1" => {
    :ip  => "192.168.56.65",
    :mac => "5CA1AB1E0001",
    :bridge => nil,
    :memory => "1024",
    :cpus => "1",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vc2" => {
    :ip  => "192.168.56.66",
    :mac => "5CA1AB1E0002",
    :bridge => nil,
    :memory => "1280",
    :cpus => "1",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vclogin" => {
    :ip  => "192.168.56.73",
    :mac => "5CA1AB1E0106",
    :bridge => nil,
    :memory => "1280",
    :cpus => "1",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 },
 "vcgate" => {
    :ip  => "192.168.56.69",
    :mac => "5CA1AB1E005A",
    :bridge => nil,
    :memory => "1280",
    :cpus => "1",
    :ingestfromhost => {	
      path: nil,
      args: nil
    },
    :adddiskpath => nil
 }
}

# the above  will be replaced per-cluster with the constructed nodes table

Vagrant.configure("2") do |config|
  config.vm.box = "generic/centos7"

  config.ssh.forward_env   = ["TZ", "LC_ALL", "VC"]
  config.ssh.forward_agent = true
  config.ssh.forward_x11   = true

  # useful so that the environment's proxy can be set very early, such as to install the NFS plugin
  unless Vagrant.has_plugin?("vagrant-proxyconf")
    puts 'Installing vagrant-proxyconf plugin...'
    system('vagrant plugin install vagrant-proxyconf')
  end

  if Vagrant.has_plugin?("vagrant-proxyconf")
    config.proxy.http = ENV["http_proxy"]
    config.proxy.no_proxy = ".lanl.gov,128.165"
    config.yum_proxy.http = ENV["http_proxy"]
    # config.proxy.RSYNC_PROXY = ENV["RSYNC_PROXY"]
  end

  config.vm.provision "shell", path:  "../common/bin/provision.sh"


# the following will be replaced per-cluster with the synced_folder table


# configuration recipe
  config.vm.synced_folder ".",               "/vagrant", create: true, type: "virtualbox"

# ingestion
  config.vm.synced_folder "../../tarballs",   "/vc/xfr", create: true, type: "virtualbox"
  config.vm.synced_folder "../../tarballs",   "/vx/xfr", create: true, type: "virtualbox"

# tools
  config.vm.synced_folder "../common/bin",    "/vagrant/cfg/provision/bin",          create: true, type: "virtualbox"
  config.vm.synced_folder "../common/env",    "/vc/cfg/provision/env",    create: true, type: "virtualbox"
  config.vm.synced_folder "../common/flag",   "/vc/cfg/provision/flag",   create: true, type: "virtualbox"
  config.vm.synced_folder "../common/inc",    "/vc/cfg/provision/inc",    create: true, type: "virtualbox"
  config.vm.synced_folder "../common/lib",    "/vc/cfg/provision/lib",    create: true, type: "virtualbox"
  config.vm.synced_folder "../common/loader", "/vc/cfg/provision/loader", create: true, type: "virtualbox"

# this cluster configuration
  config.vm.synced_folder "../vx",            "/vx",            create: true, type: "virtualbox"
  config.vm.synced_folder "../vc",            "/vc",            create: true, type: "virtualbox"
  config.vm.synced_folder "../vc", "/vc", create: true, type: "virtualbox"

# -*- mode: ruby -*-
# vim: set ft=ruby tabstop=2 shiftwidth=2 syntax=on background=dark :
 
# the above will be replaced per-cluster with the synced_folder table
 

# config.vm.network # eth0 will always be NAT (Vagrant requirement)

  nodes.each_with_index do |(hostnm,manifest), index|
    config.vm.define hostnm do |cfg|
      cfg.vm.provider :virtualbox do |vb, override|
        vb.memory = manifest[:memory].chomp
        vb.cpus = manifest[:cpus].chomp

        override.vm.hostname = hostnm
				override.vm.graceful_halt_timeout = 10
        override.vm.network "private_network", nic_type: "virtio",
															:ip => manifest[:ip],
															:mac => manifest[:mac]

        if manifest[:bridge] then
          override.vm.network "public_network",
															:ip => manifest[:ip],
															nic_type: "virtio",
															:bridge => manifest[:bridge]
        end # manifest[:bridge]

        override.trigger.before [:up] do |noduplicate|
          noduplicate.run = {path: "../common/bin/nodup.sh", args: hostnm }
        end # override.trigger.before[:up]

				if #{manifest[:ingestfromhost]}.chomp then
          override.trigger.before [:up] do |ingestfromhost|

### XXX FIXME
### XXX     manifest[:ingestfromhost].each do |key,value|
### XXX       print "       ", "#{key}  #{value}\n"
### XXX     end
### XXX Doesn't execute unless run method is set, but need to set path and args

            ingestfromhost.run = { path: "../common/bin/ingestfromhost.sh" , args: "vcfs :DOTFILES :DOTSSH" }
### XXX FIXME ingestfromhost.run = { path: manifest[:ingestfromhost[#{path}]], args: manifest[:ingestfromhost[#{:args}]] }

          end # override.trigger.before [:up]
				end # manifest[:ingestfromhost]

        # use host's dns resolver
        vb.customize ["modifyvm", :id, "--natdnshostresolver1", "on"]
        vb.customize ["modifyvm", :id, "--natdnsproxy1", "on"]

        # allow IO to use additional cpu cores
        vb.customize ["modifyvm", :id, "--ioapic", "on"]

        if manifest[:adddiskpath] then
          unless File.exist?(manifest[:adddiskpath])
            vb.customize ['createhd', '--filename', manifest[:adddiskpath],
														'--variant', 'Fixed', '--size', REPODISK_SIZE * 1024]
        end # File.exit?(manifest[:adddiskpath])

        vb.customize ['storageattach', :id,  '--storagectl', 'IDE Controller', '--port', 1, '--device', 0,
  													'--type', 'hdd', '--medium', manifest[:adddiskpath]]
        end # manifest[:adddiskpath]

        override.trigger.before [:destroy] do |unprovision|
          unprovision.run = {path: "../common/bin/unprovision.sh", args: hostnm }
        end # override.trigger.before

      end # cfg.vm.provider
    end # config.vm
  end # nodes
end # configure
