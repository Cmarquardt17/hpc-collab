#!/bin/bash

SCRIPT=$(realpath $0)   # script absolute path
MONITOR_DIR=$(dirname $SCRIPT) # script's directory
# directory for data generated by this script
if [[ $HOSTNAME:0:2} == "vc"* ]]; then
	LOGDIR=/home/vagrant/common/provision/useradd/$(whoami)/verify/provisioned/$HOSTNAME/monitor/logs
else
	LOGDIR="${LOGDIR:-${MONITOR_DIR}/logs}"
fi

FILE_TIMESTAMP=$(date +"%d-%H-%M-%S")
TTC_TIMESTAMP="$(date +%s)"

# temp files for this script
TTC_FILE=/tmp/$(ls -t /tmp | grep ttc_ | head -n 1)
# lock file for communication between populateLogs.sh and logging.sh
STATE_FILE=/tmp/state_$(date +%M%S).txt
touch $STATE_FILE # begin populating logs

# check if parent script generated a time to complete
if [ ! -f "${TTC_FILE}" ] ; then
  printf "TTC_FILE:${TTC_FILE} not a file?\n"
  exit 98
fi

printf "0. Creating log for $FILE_TIMESTAMP\n"
printf "This is the format for the raw data delmitied by commas\n"

LOGCURRENTDIR=""$LOGDIR"/"$FILE_TIMESTAMP""
NETSTATDIR="netstat"
IOSTATDIR="iostat"
MEMALLOCDIR="memAlloc"
CPUPROCDIR="cpuProcTop3"
VMSTATDIR="vmstat"
MPSTATDIR="mpstat"

#Creates the directories needed for each instance
mkdir -p $LOGCURRENTDIR/{$NETSTATDIR,$MPSTATDIR,$VMSTATDIR,$IOSTATDIR,$MEMALLOCDIR,$CPUPROCDIR}

#arrays that hold data for graphing for tools
declare -A _iostat_arr
declare -A _net_iface_arr
declare -A _net_packets_arr
declare -A _mem_arr
declare -A _cpu_proc_arr

#initt process variables so they are global so we can talk between functions
vm_process=0
mp_process=0

#array for putting timestamps on interval tools
declare -A _time_arr

#variables used for time manipulation
START_TIME=$(date +"%H:%M:%S")
TEXT_STARTTIME=$(date '+%H-%M-%S')

#vmstat creation of raw logs and grabbing the process number
_vmstat_data () {
	vmstat -t 1 >> "$LOGCURRENTDIR"/"$VMSTATDIR"/vmstatLogRaw.txt &
  vm_process=$(echo $!)
	echo "This is the vmstat PID: $vm_process"
}

#mpstat creation of raw logs and grabbing the process number
_mpstat_data () {
  mpstat -u 1 >> "$LOGCURRENTDIR"/"$MPSTATDIR"/mpstatLogRaw.txt &
  mp_process=$(echo $!)
  echo "This is mpstat PID: $mp_process"
}

#Editing the mpstatLogRaw.txt to grab importnat lines and add the correct time stamp to it
#Could be refactored when time manipulation could be a funciton itself for interval tools
_mpstat_edit_data () {
  local _mp_file="$LOGCURRENTDIR"/"$MPSTATDIR"/mpstatLogRaw.txt

  #Incrementer to make sure we are in the right place for arrays and txt files
  local _count=0
  local _t=0
  #We are reading a mpstatRaw.txt and normalizing it
  while IFS= read -r line
    do

      #We want to skip the first three lines as they will make graph.sh error out
      if [[ $_count -gt 2 ]] ;
        then
					#grabbing each line on the raw data file
					local _mpstat_out=$(echo $line)

					#As of right now this is to avoid the average line at the very end
          local _avoid_line=$(echo $_mpstat_out \
          | awk ' { printf $1 }')

     			if [[ "$_avoid_line" != "Average" ]];
            then
            #Percentage of time the CPU(s) were idle when the system had a disk I/O request
            local _iowait=$(echo $_mpstat_out \
            | awk ' { printf $7 }')

            # Percentage of time spent by CPU(s) to service hardware interrupts
            local _irq=$(echo $_mpstat_out \
            | awk ' { printf $8 }')

            #Percentage of time spent by CPU(s) to service software interrupts
            local _soft=$(echo $_mpstat_out \
            | awk ' { printf $9 }')

        		#Percentage of time spent involuntary by virtual CPU(s) while hypervisor was serving another virt-proc
            local _steal=$(echo $_mpstat_out \
            | awk ' { printf $10 }')

            #Percentage of time spent by CPU(s) to run a virtual proc
            local _guest=$(echo $_mpstat_out \
            | awk ' { printf $11 }')

						#The final product for a line in the refined txt doc
            printf "${_time_arr[$_t]}.000000,${_iowait},${_irq},${_soft},${_steal},${_guest}\n" >> "$LOGCURRENTDIR"/"$MPSTATDIR"/mpstatLog.txt
          fi
        fi
      _count=$(($_count+1))
      _t=$(($_t+1))
    done < $_mp_file

}

#Editing the vmstatLogRaw.txt to grab importnat lines and add the correct time stamp to it
#Could be refactored when time manipulation could be a funciton itself for interval tools
_vmstat_edit_data () {
	local _vm_file="$LOGCURRENTDIR"/"$VMSTATDIR"/vmstatLogRaw.txt

	#Incrementer to make sure we are in the right place for arrays and txt files
  local _count=0
	local _t=0

  #We are reading a vmstatRaw.txt and normalizing it
	while IFS= read -r line
		do

			#We want to skip the few two lines as they will make graph.sh error out
			if [[ $_count -gt 1 ]] ;
				then
					#Init variables
					local _vmstat_out=$(echo $line)
					local _avoid_line=$(echo $_vmstat_out \
					| awk ' { printf $1 }')
					if [[ "$_avoid_line" != "procs" && "$_avoid_line" != "r" ]];
						then
						#System
  					# number of interrupts per second, including the clock
  					local _sys_in=$(echo $_vmstat_out \
  					| awk ' { printf $10 }')

  					# number of context switches per second
  					local _sys_cs=$(echo $_vmstat_out \
  					| awk ' { printf $11 }')

						# CPU -- times below are as percentages of total CPU time
		  			# time spent running non-kernel code
		  			local _cpu_us=$(echo $_vmstat_out \
		  			| awk ' { printf $12 }')

		  			# time spent running kernel code
		  			local _cpu_sy=$(echo $_vmstat_out \
		  			| awk ' { printf $13 }')

		  			# time spent idle
		  			local _cpu_id=$(echo $_vmstat_out \
		  			| awk ' { printf $14 }')

  					# time spent waiting for IO
  					local _cpu_wa=$(echo $_vmstat_out \
  					| awk ' { printf $15 }')

  					# time stolen from virtual machine
						# resources stolen from not allocated
						local _cpu_st=$(echo $_vmstat_out \
	  				| awk ' { printf $16 }')
						printf "${_time_arr[$_t]}.000000,${_sys_in},${_sys_cs},${_cpu_us},${_cpu_sy},${_cpu_id},${_cpu_wa},${_cpu_st}\n" >> "$LOGCURRENTDIR"/"$VMSTATDIR"/vmstatLog.txt
					fi
				fi
			_count=$(($_count+1))
			_t=$(($_t+1))
		done < $_vm_file

}

_time_populate () {
 #Start of manipulating time, tried to directly manipulate date, but had to go another route
  local _end_time=$(date +"%H:%M:%S")
  local _start_date=$(date -u -d "$START_TIME" +"%s")
  local _final_date=$(date -u -d "$_end_time" +"%s")
  local _accum_time=$(date -u -d "0 $_final_date sec - $_start_date sec" +"%H:%M:%S")
  IFS=: read -r Hours Mins Secs <<< "$_accum_time"
  local _total_time=$((($Hours*3600)+($Mins*60 + $Secs)*2))
  echo $_total_time
  # Here we are incrementing over the amonut of time vmstat took and appending a timestamp to it
  for (( i=0; i<=$_total_time; i++ ))
    do
      local _time_holder=$(date -d"$START_TIME 2020-08-05 +$i seconds" +"%Y-%m-%d %H:%M:%S")
      local _stime=$( echo $_time_holder | awk ' { printf $2 }')
      local _stime_trim="${_stime//:/$'-'}"
      local _current_day=$(date +"%d")
      local _stime_final=$(printf "${_current_day}-${_stime_trim}\n")
      _time_arr[$i]=$_stime_final
    done
}
_collect_data () {
	# update timestamp
  TIMESTAMP=$(date +"%d-%H-%M-%S.%6N")
  TTC_TIMESTAMP="$(date +%s)"

	#For iostat
  local RkB=$(iostat -x \
	| awk '/sda/ { printf $6}')

	local WkB=$(iostat -x \
	| awk '/sda/ { printf $7}')

  local IOSTAT_OUT=$(iostat -y 1 1)

	# percentage of cpu utilization that occurred while executing at the user level
	local USER=$( echo $IOSTAT_OUT \
	| awk ' { printf $15 }')

	# percentage of cpu utilization that occurred while executing at the user level
	# with nice priority
	local NICE=$( echo $IOSTAT_OUT \
	| awk ' { printf $16 }')

	# percentage of cpu utilization that occurred while executing at the system level
	local SYSTEM=$( echo $IOSTAT_OUT \
	| awk ' { printf $17 }')

	local IOWAIT=$( echo $IOSTAT_OUT \
	| awk ' { printf $18 }')

	local STEAL=$( echo $IOSTAT_OUT \
	| awk ' { printf $19 }')

	local IDLE=$( echo $IOSTAT_OUT \
	| awk ' { printf $20 }')

  _iostat_arr[$K]="${TIMESTAMP},${RkB},${WkB},${USER},${NICE},${SYSTEM},${IOWAIT},${STEAL},${IDLE}"

  #This is for packets using the command netstat on ip, tcp, udp
  local _ip_recvd=$(netstat -s \
	| grep "total packets" \
	| awk '{print $1}')

	local _ip_send=$(netstat -s \
	| grep "requests sent out" \
	| awk '{print $1}')

	local _tcp_recvd=$(netstat -s \
	| grep "segments received" \
	| grep -ve "bad" \
	| awk '{print $1}')

	local _tcp_sent=$(netstat -s \
	| grep "segments send out" \
	| awk '{print $1}')

	local _udp_recvd=$(netstat -s \
	| grep "packets received" \
	| grep -ve "total" \
	| grep -ve "DSACKs" \
	| awk '{print $1}')

	local _udp_sent=$(netstat -s \
	| grep "packets sent" \
	| awk '{print $1}')

	_net_packets_arr[$K]="${TIMESTAMP},${_ip_recvd},${_ip_send},${_tcp_recvd},${_tcp_sent},${_udp_recvd},${_udp_sent}"

  #This is for the command netstat on the three interfaces... eno0 eth0, and lo
  local NETSTATINFO=$(netstat -i \
	| awk 'FNR > 2 { printf $1","$3","$7","}')

	_net_iface_arr[$K]="${TIMESTAMP},${NETSTATINFO}"

  #For the Memory allocation in /proc/meminfo
  local MEMFREE=$(grep -i memfree /proc/meminfo \
	| awk '{print $2}')

	local MEMAVAI=$(grep -i memavail /proc/meminfo \
	| awk '{print $2}')

	local MEMTOTAL=$(grep -i memtotal /proc/meminfo \
	| awk '{print $2}')

	_mem_arr[$K]="${TIMESTAMP},${MEMTOTAL},${MEMFREE},${MEMAVAI}"

  #For Top3CPUProcesses
  local CPUPROC=$(ps aux \
	| sort -nrk 3,3 \
	| head -n 3 \
	| awk '{print $11}')

  _cpu_proc_arr[$K]="${TIMESTAMP},${CPUPROC}"
} # _collect_data

_write_data () {
	echo "Writing logs ($KLogsWritten,$K) to file"
	for i in `seq $KLogsWritten $(($K-1))`
	do
  	 # for iostat
   	echo "${_iostat_arr["$i"]}" >> "$LOGCURRENTDIR"/"$IOSTATDIR"/iostatLog.txt

   	# For netstat PACK
   	X=${_net_packets_arr["$i"]}
   	IFS=, read -r timeSt IPR IPS TCPR TCPS UDPR UDPS <<< "$X"
   	echo "${timeSt},${IPS},${IPR}" >> "$LOGCURRENTDIR"/"$NETSTATDIR"/IPLog.txt
   	echo "${timeSt},${TCPS},${TCPR}" >> "$LOGCURRENTDIR"/"$NETSTATDIR"/TCPLog.txt
   	echo "${timeSt},${UDPS},${UDPR}" >> "$LOGCURRENTDIR"/"$NETSTATDIR"/UDPLog.txt

   	#For netstat
   	echo "${_net_iface_arr["$i"]}" >> "$LOGCURRENTDIR"/"$NETSTATDIR"/InterfaceLog.txt

   	#For memAlloc
   	echo "${_mem_arr["$i"]}" >> "$LOGCURRENTDIR"/"$MEMALLOCDIR"/memAllocLog.txt

   	#For top 3 CPU Processes
   	X=$(echo "${X}" \
	 	| gawk '{print $1 $2}')
   	echo $X >> "$LOGCURRENTDIR"/"$CPUPROCDIR"/cpuTop3Processes.txt
	done
}

echo "1. executing for loop to read data...."
echo "$(cat $TTC_FILE)"
echo "This is the start TIMESTAMP:$TTC_TIMESTAMP"

KLogsWritten=0 # number of logs written to files
K=0 # current log number counter

#Execute vmstat and kill when populate logs finishs by process ID
_vmstat_data
_mpstat_data

#while loop to add data and write the data
while [[ $(cat $TTC_FILE) -ge $TTC_TIMESTAMP ]]; do
  _collect_data

  sleep 2
  K=$(($K+1)) # increment counter

	# $SECONDS is a built-in seconds timer
	if [ $SECONDS -ge 30 ]; then
		start=$(date +%s)
		#Loop through all arrays and add data to their txt files
		( _write_data ) &

		#restart the SECONDS counter
		SECONDS=0
		end=$(date +%s)

		#We want to keep the last length so we dont overwrite
		# or miss values for the for loop
		KLogsWritten=${K}
		echo "2. Data reading finished... time it took : $(($end-$start)) seconds"
	fi
done # for timestamp ge ttc
echo "Killing vmstat"
kill $vm_process 2> /dev/null
echo "Killing mpstat"
kill $mp_process 2> /dev/null

#To fill the _time_arr for populating txt files
_time_populate

#We want to edit vmstat to get the values for graphing
_vmstat_edit_data

#We want to edit mpstat to get the values for graphing
_mpstat_edit_data

echo "3. Done with populating data log! "
rm $STATE_FILE # end populating logs
